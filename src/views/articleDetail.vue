<template>
  <div class="detail">
    <div class="left clearfix">
      <div class="header">
        <h1 class="title">{{articleDetail.title}}</h1>
        <div class="author">
          <div class="avatar">
            <img src="../assets/avat.jpg">
          </div>
          <div class="info">
            <span class="name">{{articleDetail.author}}</span>
            <div class="meta">
              <span class="meta-item">{{articleDetail.create_time}}</span>
              <span class="meta-item">字数 {{articleDetail.numbers}}</span>
              <span class="meta-item">阅读 {{articleDetail.meta.views}}</span>
              <span class="meta-item">评论 {{articleDetail.meta.comments}}</span>
              <span class="meta-item">喜欢 {{articleDetail.meta.likes}}</span>
            </div>
          </div>
          <div class="tags "
               title="标签">
            <el-tag size="mini"
                    v-for="tag in articleDetail.tags"
                    :key="tag._id"
                    class="tag"
                    type="success">{{tag.name}}</el-tag>
          </div>
        </div>
        <span class="clearfix" />
      </div>
      <div class="content">
        <div id="content"
             class="article-detail"
             v-html="articleDetail.content">
        </div>
      </div>
    </div>
    <div class="right">

    </div>
  </div>
</template>

<script>
/* eslint-disable */
import markdown from "@/utils/markdown"
export default {
  data () {
    return {
      articleDetail: '',
      articles: { "code": 0, "message": "操作成功 ！", "data": { "meta": { "views": 1562, "likes": 7, "comments": 17 }, "keyword": ["桶排序", "计数排序", "基数排序"], "desc": "之所以把计数排序、桶排序、基数排序 放在一起比较，是因为它们的平均时间复杂度都为 O(n)。", "numbers": "13780", "img_url": "https://upload-images.jianshu.io/upload_images/12890819-bc640d464b56aac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240", "type": 1, "state": 1, "origin": 0, "tags": [{ "_id": "5cf37d2874289f3d47ed1468", "name": "数据结构与算法", "desc": "数据结构与算法", "create_time": "2019-06-02T07:39:20.849Z", "update_time": "2019-06-02T07:39:20.849Z", "id": 23, "__v": 0 }], "comments": [{ "user": { "name": "0xl2oot", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22446229?v=4", "user_id": "5d494f00662d5e73c62cba91" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d494f0f662d5e73c62cba92", "article_id": "5d405a1896cf541789792486", "content": "测试", "user_id": "5d494f00662d5e73c62cba91", "other_comments": [{ "user": { "name": "1234", "type": 1, "avatar": "user", "user_id": "5d51899b662d5e73c62cba9f" }, "to_user": { "name": "0xl2oot", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22446229?v=4", "user_id": "5d494f00662d5e73c62cba91" }, "likes": 0, "state": 1, "create_time": "2019-08-12T15:47:09.629Z", "_id": "5d5189fd662d5e73c62cbaa0", "content": "组件测试" }, { "user": { "name": "1234", "type": 1, "avatar": "user", "user_id": "5d51899b662d5e73c62cba9f" }, "to_user": { "name": "1234", "type": 1, "avatar": "user", "user_id": "5d51899b662d5e73c62cba9f" }, "likes": 0, "state": 1, "create_time": "2019-08-12T15:55:33.635Z", "_id": "5d518bf5662d5e73c62cbaa2", "content": "学习" }, { "user": { "name": "leech", "type": 1, "avatar": "user", "user_id": "5d57a2ac662d5e73c62cbaad" }, "to_user": { "name": "1234", "type": 1, "avatar": "user", "user_id": "5d51899b662d5e73c62cba9f" }, "likes": 0, "state": 1, "create_time": "2019-08-17T06:46:15.670Z", "_id": "5d57a2b7662d5e73c62cbaae", "content": "123" }, { "user": { "name": "Sception", "type": 2, "avatar": "https://avatars3.githubusercontent.com/u/22490215?v=4", "user_id": "5d6ccbde662d5e73c62cbad4" }, "to_user": { "name": "0xl2oot", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22446229?v=4", "user_id": "5d494f00662d5e73c62cba91" }, "likes": 0, "state": 1, "create_time": "2019-09-02T07:59:51.646Z", "_id": "5d6ccbf7662d5e73c62cbad5", "content": "22222" }, { "user": { "name": "CoCoyh", "type": 2, "avatar": "https://avatars1.githubusercontent.com/u/24558814?v=4", "user_id": "5ce36ac774289f3d47ed141f" }, "to_user": { "name": "1234", "type": 1, "avatar": "user", "user_id": "5d51899b662d5e73c62cba9f" }, "likes": 0, "state": 1, "create_time": "2019-09-18T03:19:18.816Z", "_id": "5d81a236662d5e73c62cbb1d", "content": "666" }], "create_time": "2019-08-06T09:57:35.378Z", "update_time": "2019-08-06T09:57:35.378Z", "id": 136, "__v": 0 }, { "user": { "name": "leech", "type": 1, "avatar": "user", "user_id": "5d57a2ac662d5e73c62cbaad" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d57a2c3662d5e73c62cbab2", "article_id": "5d405a1896cf541789792486", "content": "123", "user_id": "5d57a2ac662d5e73c62cbaad", "other_comments": [], "create_time": "2019-08-17T06:46:27.042Z", "update_time": "2019-08-17T06:46:27.042Z", "id": 138, "__v": 0 }, { "user": { "name": "hellojiakewei", "type": 2, "avatar": "https://avatars3.githubusercontent.com/u/18321517?v=4", "user_id": "5d5b67c6662d5e73c62cbab9" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d5b6809662d5e73c62cbaba", "article_id": "5d405a1896cf541789792486", "content": "加个微信可好 咨询点问题  微信：17733780805", "user_id": "5d5b67c6662d5e73c62cbab9", "other_comments": [], "create_time": "2019-08-20T03:24:57.140Z", "update_time": "2019-08-20T03:24:57.140Z", "id": 139, "__v": 0 }, { "user": { "name": "Sception", "type": 2, "avatar": "https://avatars3.githubusercontent.com/u/22490215?v=4", "user_id": "5d6ccbde662d5e73c62cbad4" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d6ccc14662d5e73c62cbada", "article_id": "5d405a1896cf541789792486", "content": "测试测试测试", "user_id": "5d6ccbde662d5e73c62cbad4", "other_comments": [], "create_time": "2019-09-02T08:00:20.942Z", "update_time": "2019-09-02T08:00:20.942Z", "id": 141, "__v": 0 }, { "user": { "name": "vim", "type": 1, "avatar": "user", "user_id": "5d6f58b1662d5e73c62cbadb" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d6f58d4662d5e73c62cbadc", "article_id": "5d405a1896cf541789792486", "content": "这么多测试的，文章不错，非常 Nice!", "user_id": "5d6f58b1662d5e73c62cbadb", "other_comments": [], "create_time": "2019-09-04T06:25:24.721Z", "update_time": "2019-09-04T06:25:24.721Z", "id": 142, "__v": 0 }, { "user": { "name": "Jacwo", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "user_id": "5d75ec65662d5e73c62cbae7" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d75fb9b662d5e73c62cbaf0", "article_id": "5d405a1896cf541789792486", "content": "test", "user_id": "5d75ec65662d5e73c62cbae7", "other_comments": [{ "user": { "name": "Jacwo", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "user_id": "5d75ec65662d5e73c62cbae7" }, "to_user": { "name": "Jacwo", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "user_id": "5d75ec65662d5e73c62cbae7" }, "likes": 0, "state": 1, "create_time": "2019-09-09T07:14:13.091Z", "_id": "5d75fbc5662d5e73c62cbaf1", "content": "test" }, { "user": { "name": "Jacwo", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "user_id": "5d75ec65662d5e73c62cbae7" }, "to_user": { "name": "Jacwo", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "user_id": "5d75ec65662d5e73c62cbae7" }, "likes": 0, "state": 1, "create_time": "2019-09-09T07:15:13.278Z", "_id": "5d75fc01662d5e73c62cbaf3", "content": "test" }], "create_time": "2019-09-09T07:13:31.330Z", "update_time": "2019-09-09T07:13:31.330Z", "id": 144, "__v": 0 }, { "user": { "name": "1014470807", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/29792931?v=4", "user_id": "5d7764df662d5e73c62cbaf8" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d79b7d3662d5e73c62cbb11", "article_id": "5d405a1896cf541789792486", "content": "VB传不", "user_id": "5d7764df662d5e73c62cbaf8", "other_comments": [], "create_time": "2019-09-12T03:13:23.971Z", "update_time": "2019-09-12T03:13:23.971Z", "id": 145, "__v": 0 }, { "user": { "name": "charliecha1990", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22619205?v=4", "user_id": "5d92b970662d5e73c62cbb4b" }, "is_top": false, "likes": 0, "state": 1, "is_handle": 1, "_id": "5d92b993662d5e73c62cbb4c", "article_id": "5d405a1896cf541789792486", "content": "dsadda", "user_id": "5d92b970662d5e73c62cbb4b", "other_comments": [{ "user": { "name": "charliecha1990", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22619205?v=4", "user_id": "5d92b970662d5e73c62cbb4b" }, "to_user": { "name": "charliecha1990", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22619205?v=4", "user_id": "5d92b970662d5e73c62cbb4b" }, "likes": 0, "state": 1, "create_time": "2019-10-01T02:28:00.848Z", "_id": "5d92b9b0662d5e73c62cbb4d", "content": "测试" }, { "user": { "name": "charliecha1990", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22619205?v=4", "user_id": "5d92b970662d5e73c62cbb4b" }, "to_user": { "name": "charliecha1990", "type": 2, "avatar": "https://avatars0.githubusercontent.com/u/22619205?v=4", "user_id": "5d92b970662d5e73c62cbb4b" }, "likes": 0, "state": 1, "create_time": "2019-10-01T02:28:13.356Z", "_id": "5d92b9bd662d5e73c62cbb4f", "content": "测试" }], "create_time": "2019-10-01T02:27:31.533Z", "update_time": "2019-10-01T02:27:31.533Z", "id": 148, "__v": 0 }], "category": [{ "desc": "javaScript", "_id": "5bf014e8bc1e7805eb83dba7", "name": "javaScript", "create_time": "2018-11-17T13:17:28.907Z", "update_time": "2018-11-17T13:17:28.907Z", "id": 1, "__v": 0 }], "_id": "5d405a1896cf541789792486", "title": "JavaScript 数据结构与算法之美 - 桶排序、计数排序、基数排序", "author": "biaochenxuying", "content": "![JavaScript 数据结构与算法之美](https://upload-images.jianshu.io/upload_images/12890819-9f08a1abed2d7caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 1. 前言\n\n> 算法为王。\n\n**想学好前端，先练好内功，只有内功深厚者，前端之路才会走得更远**。\n\n笔者写的 **JavaScript 数据结构与算法之美** 系列用的语言是 **JavaScript** ，旨在入门数据结构与算法和方便以后复习。\n\n之所以把 **计数排序、桶排序、基数排序** 放在一起比较，是因为它们的平均时间复杂度都为 **O(n)**。\n\n因为这三个排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作 **线性排序**（Linear sort）。\n\n之所以能做到线性的时间复杂度，主要原因是，这三个算法不是基于比较的排序算法，都不涉及元素之间的比较操作。\n\n另外，请大家带着问题来阅读下文，问题：如何根据年龄给 100 万用户排序 ？\n\n## 2. 桶排序（Bucket Sort）\n\n桶排序是计数排序的升级版，也采用了`分治思想`。\n\n**思想**\n\n- 将要排序的数据分到有限数量的几个有序的桶里。\n- 每个桶里的数据再单独进行排序（一般用插入排序或者快速排序）。\n- 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n\n比如：\n\n![](https://upload-images.jianshu.io/upload_images/12890819-fbe2b3e3d6d56b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n\n为了使桶排序更加高效，我们需要做到这两点：\n- 在额外空间充足的情况下，尽量增大桶的数量。\n- 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。\n\n桶排序的核心：就在于怎么把元素平均分配到每个桶里，合理的分配将大大提高排序的效率。\n\n\n\n**实现**\n\n```javascript\n// 桶排序\nconst bucketSort = (array, bucketSize) => {\n  if (array.length === 0) {\n    return array;\n  }\n\n  console.time('桶排序耗时');\n  let i = 0;\n  let minValue = array[0];\n  let maxValue = array[0];\n  for (i = 1; i < array.length; i++) {\n    if (array[i] < minValue) {\n      minValue = array[i]; //输入数据的最小值\n    } else if (array[i] > maxValue) {\n      maxValue = array[i]; //输入数据的最大值\n    }\n  }\n\n  //桶的初始化\n  const DEFAULT_BUCKET_SIZE = 5; //设置桶的默认数量为 5\n  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;\n  const buckets = new Array(bucketCount);\n  for (i = 0; i < buckets.length; i++) {\n    buckets[i] = [];\n  }\n\n  //利用映射函数将数据分配到各个桶中\n  for (i = 0; i < array.length; i++) {\n    buckets[Math.floor((array[i] - minValue) / bucketSize)].push(array[i]);\n  }\n\n  array.length = 0;\n  for (i = 0; i < buckets.length; i++) {\n    quickSort(buckets[i]); //对每个桶进行排序，这里使用了快速排序\n    for (var j = 0; j < buckets[i].length; j++) {\n      array.push(buckets[i][j]);\n    }\n  }\n  console.timeEnd('桶排序耗时');\n\n  return array;\n};\n\n// 快速排序\nconst quickSort = (arr, left, right) => {\n\tlet len = arr.length,\n\t\tpartitionIndex;\n\tleft = typeof left != 'number' ? 0 : left;\n\tright = typeof right != 'number' ? len - 1 : right;\n\n\tif (left < right) {\n\t\tpartitionIndex = partition(arr, left, right);\n\t\tquickSort(arr, left, partitionIndex - 1);\n\t\tquickSort(arr, partitionIndex + 1, right);\n\t}\n\treturn arr;\n};\n\nconst partition = (arr, left, right) => {\n\t//分区操作\n\tlet pivot = left, //设定基准值（pivot）\n\t\tindex = pivot + 1;\n\tfor (let i = index; i <= right; i++) {\n\t\tif (arr[i] < arr[pivot]) {\n\t\t\tswap(arr, i, index);\n\t\t\tindex++;\n\t\t}\n\t}\n\tswap(arr, pivot, index - 1);\n\treturn index - 1;\n};\n\nconst swap = (arr, i, j) => {\n\tlet temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n};\n```\n\n**测试**\n\n```javascript\nconst array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];\nconsole.log('原始array:', array);\nconst newArr = bucketSort(array);\nconsole.log('newArr:', newArr);\n// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]\n// 堆排序耗时:   0.133056640625ms\n// newArr:  \t [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]\n```\n\n**分析**\n\n- 第一，桶排序是原地排序算法吗 ？\n\n因为桶排序的空间复杂度，也即内存消耗为 O(n)，所以`不是`原地排序算法。\n\n- 第二，桶排序是稳定的排序算法吗 ？\n\n取决于每个桶的排序方式，比如：快排就不稳定，归并就稳定。\n\n- 第三，桶排序的时间复杂度是多少 ？\n\n因为桶内部的排序可以有多种方法，是会对桶排序的时间复杂度产生很重大的影响。所以，桶排序的时间复杂度可以是多种情况的。\n\n`总的来说`\n最佳情况：当输入的数据可以均匀的分配到每一个桶中。\n最差情况：当输入的数据被分配到了同一个桶中。\n\n\n以下是`桶的内部排序`为`快速排序`的情况：\n\n如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k  =n / m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。\nm 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k = n / m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。\n当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。\n\n最佳情况：T(n) = O(n)。当输入的数据可以均匀的分配到每一个桶中。\n最差情况：T(n) = O(nlogn)。当输入的数据被分配到了同一个桶中。\n平均情况：T(n) = O(n)。\n\n> 桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。\n> 很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n\n**适用场景**\n\n- 桶排序比较适合用在外部排序中。\n- 外部排序就是数据存储在外部磁盘且数据量大，但内存有限，无法将整个数据全部加载到内存中。\n\n\n**动画**\n\n![bocket-sort.gif](https://upload-images.jianshu.io/upload_images/12890819-96021a791180eba0.gif?imageMogr2/auto-orient/strip)\n\n\n## 3. 计数排序（Counting Sort）\n\n**思想**\n\n- 找出待排序的数组中最大和最小的元素。\n- 统计数组中每个值为 i 的元素出现的次数，存入新数组 countArr 的第 i 项。\n- 对所有的计数累加（从 countArr 中的第一个元素开始，每一项和前一项相加）。\n- 反向填充目标数组：将每个元素 i 放在新数组的第 countArr[i] 项，每放一个元素就将 countArr[i] 减去 1 。\n\n关键在于理解最后反向填充时的操作。\n\n**使用条件**\n\n- 只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序。\n- 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数。\n- 比如如果考试成绩精确到小数后一位，就需要将所有分数乘以 10，转换为整数。\n\n**实现**\n\n方法一：\n\n```javascript\nconst countingSort = array => {\n\tlet len = array.length,\n\t\tresult = [],\n\t\tcountArr = [],\n\t\tmin = (max = array[0]);\n\tconsole.time('计数排序耗时');\n\tfor (let i = 0; i < len; i++) {\n\t\t// 获取最小，最大 值\n\t\tmin = min <= array[i] ? min : array[i];\n\t\tmax = max >= array[i] ? max : array[i];\n\t\tcountArr[array[i]] = countArr[array[i]] ? countArr[array[i]] + 1 : 1;\n\t}\n\tconsole.log('countArr :', countArr);\n\t// 从最小值 -> 最大值,将计数逐项相加\n\tfor (let j = min; j < max; j++) {\n\t\tcountArr[j + 1] = (countArr[j + 1] || 0) + (countArr[j] || 0);\n\t}\n\tconsole.log('countArr 2:', countArr);\n\t// countArr 中,下标为 array 数值，数据为 array 数值出现次数；反向填充数据进入 result 数据\n\tfor (let k = len - 1; k >= 0; k--) {\n\t\t// result[位置] = array 数据\n\t\tresult[countArr[array[k]] - 1] = array[k];\n\t\t// 减少 countArr 数组中保存的计数\n\t\tcountArr[array[k]]--;\n\t\t// console.log(\"array[k]:\", array[k], 'countArr[array[k]] :', countArr[array[k]],)\n\t\tconsole.log('result:', result);\n\t}\n\tconsole.timeEnd('计数排序耗时');\n\treturn result;\n};\n```\n\n测试\n\n```javascript\nconst array = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];\nconsole.log('原始 array: ', array);\nconst newArr = countingSort(array);\nconsole.log('newArr: ', newArr);\n// 原始 array:  [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]\n// 计数排序耗时:   5.6708984375ms\n// newArr:  \t [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]\n```\n\n![测试结果](https://upload-images.jianshu.io/upload_images/12890819-f2541143bcd69138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n方法二：\n\n```javascript\nconst countingSort2 = (arr, maxValue) => {\n\tconsole.time('计数排序耗时');\n\tmaxValue = maxValue || arr.length;\n\tlet bucket = new Array(maxValue + 1),\n\t\tsortedIndex = 0;\n\t(arrLen = arr.length), (bucketLen = maxValue + 1);\n\n\tfor (let i = 0; i < arrLen; i++) {\n\t\tif (!bucket[arr[i]]) {\n\t\t\tbucket[arr[i]] = 0;\n\t\t}\n\t\tbucket[arr[i]]++;\n\t}\n\n\tfor (let j = 0; j < bucketLen; j++) {\n\t\twhile (bucket[j] > 0) {\n\t\t\tarr[sortedIndex++] = j;\n\t\t\tbucket[j]--;\n\t\t}\n\t}\n\tconsole.timeEnd('计数排序耗时');\n\treturn arr;\n};\n```\n\n测试\n\n```javascript\nconst array2 = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];\nconsole.log('原始 array2: ', array2);\nconst newArr2 = countingSort2(array2, 21);\nconsole.log('newArr2: ', newArr2);\n// 原始 array:  [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]\n// 计数排序耗时:   0.043212890625ms\n// newArr:  \t [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]\n```\n\n**例子**\n\n可以认为，**计数排序其实是桶排序的一种特殊情况**。\n\n当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。\n\n我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？\n\n- 考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。\n- 根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。\n- 我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。\n- 因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。\n\n**分析**\n\n- 第一，计数排序是原地排序算法吗 ？\n因为计数排序的空间复杂度为 O(k)，k 是桶的个数，所以不是原地排序算法。 \n- 第二，计数排序是稳定的排序算法吗 ？\n计数排序不改变相同元素之间原本相对的顺序，因此它是稳定的排序算法。\n- 第三，计数排序的时间复杂度是多少 ？\n最佳情况：T(n) = O(n + k)\n最差情况：T(n) = O(n + k)\n平均情况：T(n) = O(k)\nk：桶的个数。\n\n\n\n**动画**\n\n![counting-sort.gif](https://upload-images.jianshu.io/upload_images/12890819-43b26f260d905c77.gif?imageMogr2/auto-orient/strip)\n\n\n## 4. 基数排序（Radix Sort）\n\n**思想**\n\n基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。\n\n由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n**例子**\n\n假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢 ？\n\n这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。所以是基于`位`来比较的。\n\n桶排序、计数排序能派上用场吗 ？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢 ？ 有，就是基数排序。\n\n\n**使用条件**\n\n- 要求数据可以分割独立的`位`来比较；\n- 位之间由递进关系，如果 a 数据的高位比 b 数据大，那么剩下的地位就不用比较了；\n- 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到 O(n)。\n\n**方案**\n\n按照优先从高位或低位来排序有两种实现方案:\n\n- MSD：由高位为基底，先按 k1 排序分组，同一组中记录, 关键码 k1 相等，再对各组按 k2 排序分成子组, 之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 kd 对各子组排序后，再将各组连接起来，便得到一个有序序列。MSD 方式适用于位数多的序列。\n- LSD：由低位为基底，先从 kd 开始排序，再对 kd - 1 进行排序，依次重复，直到对 k1 排序后便得到一个有序序列。LSD 方式适用于位数少的序列。\n\n\n**实现**\n\n```javascript\n/**\n\t* name: 基数排序\n\t* @param  array 待排序数组\n\t* @param  max 最大位数\n\t*/\nconst radixSort = (array, max) => {\n\tconsole.time('计数排序耗时');\n\tconst buckets = [];\n\tlet unit = 10,\n\t\tbase = 1;\n\tfor (let i = 0; i < max; i++, base *= 10, unit *= 10) {\n\t\tfor (let j = 0; j < array.length; j++) {\n\t\t\tlet index = ~~((array[j] % unit) / base); //依次过滤出个位，十位等等数字\n\t\t\tif (buckets[index] == null) {\n\t\t\t\tbuckets[index] = []; //初始化桶\n\t\t\t}\n\t\t\tbuckets[index].push(array[j]); //往不同桶里添加数据\n\t\t}\n\t\tlet pos = 0,\n\t\t\tvalue;\n\t\tfor (let j = 0, length = buckets.length; j < length; j++) {\n\t\t\tif (buckets[j] != null) {\n\t\t\t\twhile ((value = buckets[j].shift()) != null) {\n\t\t\t\t\tarray[pos++] = value; //将不同桶里数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconsole.timeEnd('计数排序耗时');\n\treturn array;\n};\n```\n\n测试\n\n```javascript\nconst array = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];\nconsole.log('原始array:', array);\nconst newArr = radixSort(array, 2);\nconsole.log('newArr:', newArr);\n// 原始 array:  [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]\n// 堆排序耗时:   0.064208984375ms\n// newArr:  \t [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n\n**分析**\n\n- 第一，基数排序是原地排序算法吗 ？\n因为计数排序的空间复杂度为 O(n + k)，所以不是原地排序算法。 \n\n- 第二，基数排序是稳定的排序算法吗 ？\n基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。\n\n- 第三，基数排序的时间复杂度是多少 ？\n最佳情况：T(n) = O(n * k)\n最差情况：T(n) = O(n * k)\n平均情况：T(n) = O(n * k)\nk 是待排序列最大值。\n\n\n**动画**\n\nLSD 基数排序动图演示：\n\n![radixSort.gif](https://upload-images.jianshu.io/upload_images/12890819-aff01ef4a1e19f74.gif?imageMogr2/auto-orient/strip)\n\n\n## 5. 解答开篇\n\n回过头来看看开篇的思考题：**如何根据年龄给 100 万用户排序 ？**\n\n你可能会说，我用上一节讲的归并、快排就可以搞定啊！是的，它们也可以完成功能，但是时间复杂度最低也是 O(nlogn)。\n\n有没有更快的排序方法呢 ？以下是参考答案。\n\n- 实际上，根据年龄给 100 万用户排序，就类似按照成绩给 50 万考生排序。\n- 我们假设年龄的范围最小 1 岁，最大不超过 120 岁。\n- 我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。\n- 这样就得到了按照年龄排序的 100 万用户数据。\n\n## 6. 复杂性对比\n\n**基数排序 vs 计数排序 vs 桶排序**\n\n基数排序有两种方法：\n\n- MSD 从高位开始进行排序\n- LSD 从低位开始进行排序\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n- 基数排序：根据键值的每位数字来分配桶；\n- 计数排序：每个桶只存储单一键值；\n- 桶排序：每个桶存储一定范围的数值；\n\n\n**复杂性对比**\n\n| 名称 | 平均  | 最好 | 最坏 | 空间 | 稳定性 | 排序方式 |\n|  :------: |  :------: |  :------: |  :------: |  :------: |  :------: |  :------: |\n| 桶排序 | O(n + k) | O(n + k) | O(n<sup>2</sup>) | O(n + k) | Yes | Out-place | \n| 计数排序 | O(n + k) | O(n + k) | O(n + k) | O(k) | Yes | Out-place | \n| 基数排序 | O(n * k) | O(n * k) | O(n * k) | O(n + k) | Yes | Out-place | \n\n n: 数据规模\n\n> 桶排序的时间复杂度可以是多种情况的，取决于桶内的排序。\n\n## 7. 算法可视化工具\n\n- 算法可视化工具 [algorithm-visualizer](https://github.com/algorithm-visualizer/algorithm-visualizer) \n 算法可视化工具 algorithm-visualizer 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。\n效果如下图。\n\n![算法可视化工具](https://upload-images.jianshu.io/upload_images/12890819-0af779615ee7fc27.gif?imageMogr2/auto-orient/strip)\n\n\n旨在通过交互式可视化的执行来揭示算法背后的机制。\n\n- 算法可视化来源 [https://visualgo.net/en](https://visualgo.net/en)\n效果如下图。\n![quick-sort.gif](https://upload-images.jianshu.io/upload_images/12890819-661bf75741df7c9a.gif?imageMogr2/auto-orient/strip)\n\n- [https://www.ee.ryerson.ca](https://www.ee.ryerson.ca/~courses/coe428/sorting/insertionsort.html)\n\n![insert-sort.gif](https://upload-images.jianshu.io/upload_images/12890819-2453edc1c19e14b8.gif?imageMogr2/auto-orient/strip)\n\n\n- [illustrated-algorithms](https://github.com/skidding/illustrated-algorithms)\n变量和操作的可视化表示增强了控制流和实际源代码。您可以快速前进和后退执行，以密切观察算法的工作方式。\n\n![binary-search.gif](https://upload-images.jianshu.io/upload_images/12890819-22bd05d89a89af8c.gif?imageMogr2/auto-orient/strip)\n\n\n## 8. 系列文章\n\n**JavaScript 数据结构与算法之美** 的系列文章。\n\n\n| 标题 | 链接 | \n|  :------ |  :------ |  \n| [时间和空间复杂度](https://github.com/biaochenxuying/blog/issues/29)  | https://github.com/biaochenxuying/blog/issues/29 | \n| [线性表（数组、链表、栈、队列）](https://github.com/biaochenxuying/blog/issues/34) | https://github.com/biaochenxuying/blog/issues/34 | \n| [实现一个前端路由，如何实现浏览器的前进与后退 ？](https://github.com/biaochenxuying/blog/issues/30)| https://github.com/biaochenxuying/blog/issues/30 |\n| [栈内存与堆内存 、浅拷贝与深拷贝](https://github.com/biaochenxuying/blog/issues/34) | https://github.com/biaochenxuying/blog/issues/35 |\n| [递归](https://github.com/biaochenxuying/blog/issues/36) | https://github.com/biaochenxuying/blog/issues/36 | \n| [非线性表（树、堆）](https://github.com/biaochenxuying/blog/issues/37) | https://github.com/biaochenxuying/blog/issues/37 |\n| [冒泡排序、选择排序、插入排序](https://github.com/biaochenxuying/blog/issues/39) | https://github.com/biaochenxuying/blog/issues/39 |\n| [归并排序、快速排序、希尔排序、堆排序](https://github.com/biaochenxuying/blog/issues/40) | https://github.com/biaochenxuying/blog/issues/40 | \n| [计数排序、桶排序、基数排序](https://github.com/biaochenxuying/blog/issues/41) | https://github.com/biaochenxuying/blog/issues/41 | \n| [十大经典排序汇总](https://github.com/biaochenxuying/blog/issues/42)  | https://github.com/biaochenxuying/blog/issues/42 | \n| [强烈推荐 GitHub 上值得前端学习的数据结构与算法项目](https://github.com/biaochenxuying/blog/issues/43) | https://github.com/biaochenxuying/blog/issues/43 | \n\n> 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。\n\n\n## 9. 最后\n\n文中所有的代码及测试事例都已经放到我的 [GitHub](https://github.com/biaochenxuying/blog/tree/master/data-structure-and-algorithms) 上了。\n\n觉得有用 ？喜欢就收藏，顺便点个赞吧，你的支持是我最大的鼓励！\n\n参考文章：\n\n- [菜鸟教程 - 算法系列](https://www.runoob.com/w3cnote_genre/algorithm)\n- [线性排序：如何根据年龄给100万用户数据排序？](https://time.geekbang.org/column/article/42038)\n- [十大经典排序算法总结（JavaScript 描述）](https://juejin.im/post/57dcd394a22b9d00610c5ec8)\n- [JS 中可能用得到的全部的排序算法](https://juejin.im/post/58c9d5fb1b69e6006b686bce)\n\n\n", "like_users": [{ "name": "0xl2oot", "type": 2, "introduce": "", "avatar": "https://avatars0.githubusercontent.com/u/22446229?v=4", "create_time": "2019-08-06T09:57:20.297Z", "_id": "5d494f1d662d5e73c62cba93", "id": "5d494f00662d5e73c62cba91" }, { "name": "Jacwo", "type": 2, "introduce": "", "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "create_time": "2019-09-09T06:08:37.978Z", "_id": "5d75f7d7662d5e73c62cbae9", "id": "5d75ec65662d5e73c62cbae7" }, { "name": "Jacwo", "type": 2, "introduce": "", "avatar": "https://avatars0.githubusercontent.com/u/18608852?v=4", "create_time": "2019-09-09T06:08:37.978Z", "_id": "5d75f84c662d5e73c62cbaec", "id": "5d75ec65662d5e73c62cbae7" }, { "name": "blossom", "type": 1, "introduce": "", "avatar": "user", "create_time": "2019-09-11T09:03:09.158Z", "_id": "5d78b8a5662d5e73c62cbafc", "id": "5d78b84d662d5e73c62cbafb" }, { "name": "yuwwyi", "type": 1, "introduce": "", "avatar": "user", "create_time": "2019-09-17T06:55:41.772Z", "_id": "5d80895e662d5e73c62cbb17", "id": "5d80836d662d5e73c62cbb16" }, { "name": "hefeng6500", "type": 2, "introduce": "", "avatar": "https://avatars3.githubusercontent.com/u/26035866?v=4", "create_time": "2019-06-29T08:37:44.557Z", "_id": "5db28791e269451f500ff205", "id": "5d172358b9e26b1e10d2e5c9" }, { "name": "chenyonghui0427", "type": 2, "introduce": "", "avatar": "https://avatars0.githubusercontent.com/u/35049657?v=4", "create_time": "2020-02-14T16:03:39.651Z", "_id": "5e46c58a99e7c86832b933e2", "id": "5e46c4db99e7c86832b933e1" }], "create_time": "2019-07-30T14:54:16.633Z", "update_time": "2019-07-30T14:54:16.633Z", "id": 64, "__v": 0 } }
    }
  },
  async created () {
    this.articleDetail = this.articles.data
    // this.articleDetail.content = await markdown.marked(this.articles.data.content)
  },
  methods: {

  },
}
</script>

<style scoped>
.detail {
    width: 100%;
}
.left {
    width: 75%;
    margin-right: 2%;
    float: left;
}
.header {
    width: 100%;
    height: 160px;
}
.title {
    margin-top: 20px;
    text-align: center;
    font-size: 34px;
    font-weight: 700;
}
.author {
    position: relative;
    margin: 30px 0 0 0;
    height: 48px;
    padding-left: 50px;
}
.avatar {
    position: absolute;
    left: 0;
    top: 0;
    width: 48px;
    height: 48px;
    vertical-align: middle;
    display: inline-block;
}
.avatar > img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
}
.info {
    float: left;
    vertical-align: middle;
    margin-left: 8px;
    padding: 8px 0;
}
.meta-item {
    padding-right: 5px;
    font-size: 12px;
    color: #969696;
}
.tags {
    float: right;
    padding-top: 15px;
}
.tag {
    margin-left: 5px;
    border-right: 2px solid #eee;
}
.clearfix {
    clear: both;
}
.content {
    /* min-height: 300px; */
}
</style>
